name: "sed"
scopeName: "source.sed"
fileTypes: ["sed"]
firstLineMatch: """(?x)
	# Hashbang
	^\\#!.*(?:\\s|\\/|(?<=!)\\b)
		(?:(?:g|s|mini)?sed)
	(?:$|\\s)
	|
	# Modeline
	(?i:
		# Emacs
		-\\*-(?:\\s*(?=[^:;\\s]+\\s*-\\*-)|(?:.*?[;\\s]|(?<=-\\*-))mode\\s*:\\s*)
			sed
		(?=[\\s;]|(?<![-*])-\\*-).*?-\\*-
		|
		# Vim
		(?:(?:\\s|^)vi(?:m[<=>]?\\d+|m)?|\\sex)(?=:(?=\\s*set?\\s[^\\n:]+:)|:(?!\\s* set?\\s))(?:(?:\\s|\\s*:\\s*)\\w*(?:\\s*=(?:[^\\n\\\\\\s]|\\\\.)*)?)*[\\s:](?:filetype|ft|syntax)\\s*=
			sed
		(?=\\s|:|$)
	)
"""
patterns: [
	# Interpreter directive
	name:  "comment.line.number-sign.hashbang.source.sed"
	begin: "\\A#!"
	end:   "$"
	beginCaptures:
		0: name: "punctuation.definition.comment.source.sed"
	
	# Remainder of grammar
	{include: "#main"}
]

repository:
	main:
		patterns: [
			{include: "#comment"}
			{include: "#substitution"}
			{include: "#transliteration"}
			{include: "#addresses"}
			{include: "#braces"}
			{include: "#commands"}
		]
	
	# Stuff to limit execution to certain lines
	addresses:
		patterns: [{
			# /regexp/
			name:  "meta.address.source.sed"
			begin: "/"
			end:   "(/)([IM]*)|$"
			beginCaptures:
				0: name: "punctuation.delimiter.address.begin.source.sed"
			endCaptures:
				1: name: "punctuation.delimiter.address.end.source.sed"
				2: name: "meta.modifier.flags.source.sed", patterns: [include: "#flags"]
			contentName: "string.regexp.address.source.sed"
			patterns: [include: "#regexp"]
		},{
			# \%regexp%
			name: "meta.address.custom-delimiter.source.sed"
			begin: "\\\\(.)"
			end:   "(\\1)([IM]*)|$"
			beginCaptures:
				0: name: "punctuation.delimiter.address.begin.source.sed"
			endCaptures:
				1: name: "punctuation.delimiter.address.end.source.sed"
				2: name: "meta.modifier.flags.source.sed", patterns: [include: "#flags"]
			contentName: "string.regexp.address.source.sed"
			patterns: [include: "#regexp"]
		},{
			# GNU: Skip address
			name:  "meta.address.step.gnu.source.sed"
			match: "([0-9]+)(~)([0-9]+)"
			captures:
				1: name: "constant.numeric.integer.start-index.source.sed"
				2: name: "keyword.operator.step.range.gnu.source.sed"
				3: name: "constant.numeric.integer.step-size.source.sed"
		}]
	
	
	# { commands… }
	braces:
		name:  "meta.group.source.sed"
		begin: "{"
		end:   "}"
		beginCaptures: 0: name: "punctuation.section.scope.begin.source.sed"
		endCaptures:   0: name: "punctuation.section.scope.end.source.sed"
		patterns: [include: "#main"]
	
	
	# Single-letter commands
	commands:
		patterns: [
			{match: "d", name: "keyword.control.delete.command.source.sed"}
			{match: "p", name: "keyword.control.print.command.source.sed"}
			{match: "n", name: "keyword.control.skip.command.source.sed"}
			
			# Quit sed with optional exit status
			match: "(q)(?:\\s*([0-9]+))?"
			captures:
				1: name: "keyword.control.quit.command.source.sed"
				2: name: "variable.parameter.exit-code.gnu.source.sed"
		]
	
	
	# Lines beginning with a number-sign
	comment:
		patterns: [{
			# Special "directive" to force use of the `-n` switch
			begin: "\\A(#)n"
			end:   "$"
			beginCaptures:
				0: name: "keyword.control.directive.no-autoprint.source.sed"
				1: name: "punctuation.definition.directive.source.sed"
			contentName: "comment.line.number-sign.source.sed"
		},{
			# Ordinary comments like this one
			name:  "comment.line.number-sign.source.sed"
			begin: "#"
			end:   "$"
			beginCaptures:
				0: name: "punctuation.definition.comment.source.sed"
		}]


	# Backslash-escaped character
	escape:
		patterns: [{
			# Escaped newline
			name:  "constant.character.escape.newline.source.sed"
			begin: "\\\\$\\s*"
			end:   "^"
		},{
			# Tab
			name:  "constant.character.tab.source.sed"
			match: "\\\\t"
		},{
			# Literal newline
			name:  "constant.character.newline.source.sed"
			match: "\\\\n"
		},{
			# Anything else
			name:  "constant.character.escape.source.sed"
			match: "\\\\."
		}]

	# Regular expressions
	regexp:
		patterns: [
			{match: "\\.",      name: "constant.character.wildcard.dot.match.any.source.sed"}
			{match: "\\^",      name: "keyword.operator.anchor.line-start.source.sed"}
			{match: "\\$",      name: "keyword.operator.anchor.line-end.source.sed"}
			{match: "\\*",      name: "keyword.operator.quantifier.source.sed"}
			{match: "\\\\?\\(", name: "constant.language.group.begin.source.sed"}
			{match: "\\\\?\\)", name: "constant.language.group.end.source.sed"}
			{match: "\\\\[Ll]", name: "keyword.operator.lowercase.conversion.gnu.source.sed"}
			{match: "\\\\[Uu]", name: "keyword.operator.uppercase.conversion.gnu.source.sed"}
			{match: "\\\\E",    name: "keyword.operator.end.conversion.gnu.source.sed"}
			{include: "#regexp.bracketExpression"}
			{include: "#escape"}
		]

	# Bracket expression: [^a-f\d]
	"regexp.bracketExpression":
		name: "string.regexp.character-class.source.sed"
		begin: "\\["
		end:   "\\]|(?=$)"
		beginCaptures: 0: name: "punctuation.definition.character-class.begin.source.sed"
		endCaptures:   0: name: "punctuation.definition.character-class.end.source.sed"
		patterns: [{
			# Negation
			name: "keyword.operator.logical.not.source.sed"
			match: "\\G\\^"
		},{
			# Ignore a closing bracket if it's listed first
			match: "\\G\\]"
		},{
			# Dash separating two halves of a range expression
			name: "punctuation.separator.range.dash.source.sed"
			match: "(?<!\\G)-(?!$|\\])"
		},{
			# Named character classes [:alnum:]
			name:  "constant.language.named.character-class.source.sed"
			match: "(\\[:)(?:(alnum|alpha|blank|cntrl|digit|graph|lower|print|punct|space|upper|xdigit)|(.*?))(\\:])"
			captures:
				1: name: "punctuation.definition.character-class.begin.source.sed"
				2: name: "support.constant.posix-class.source.sed"
				3: name: "invalid.illegal.unknown.character-class.source.sed"
				4: name: "punctuation.definition.character-class.end.source.sed"
		},{
			# Collating symbol
			name:  "constant.language.collating-symbol.source.sed"
			begin: "\\[\\."
			end:   "\\.\\]|(?=$)"
			beginCaptures: 0: name: "punctuation.definition.collating-symbol.begin.source.sed"
			endCaptures:   0: name: "punctuation.definition.collating-symbol.end.source.sed"
			patterns: [include: "#escape"]
		},{
			# Equivalence class
			name:  "constant.language.equivalence-class.source.sed"
			begin: "\\[="
			end:   "=\\]"
			beginCaptures: 0: name: "punctuation.definition.equivalence-class.begin.source.sed"
			endCaptures:   0: name: "punctuation.definition.equivalence-class.end.source.sed"
			patterns: [include: "#escape"]
		}, include: "#escape"]
		

	# s/ … / … /
	substitution:
		name:  "meta.substitution.source.sed"
		begin: "s"
		end:   "$|(?=\\s)|(?<=^)"
		beginCaptures:
			0: name: "keyword.control.command.source.sed"
		patterns: [{
			begin: "\\G(.)"
			end:   "(?=\\1|$)"
			contentName:  "string.regexp.substitution.search.source.sed"
			beginCaptures:
				1: name: "punctuation.delimiter.substitution.begin.source.sed"
			patterns: [include: "#regexp"]
		},{
			begin: "(.)"
			end:   "(\\1)(?:([gp0-9eIiMm]+)|(\\S+))?|(?=$)"
			contentName: "string.quoted.double.replacement.source.sed"
			beginCaptures:
				1: name: "punctuation.delimiter.substitution.middle.source.sed"
			endCaptures:
				1: name: "punctuation.delimiter.substitution.end.source.sed"
				2: name: "meta.modifier.flags.source.sed", patterns: [include: "#flags"]
				3: name: "invalid.illegal.unknown.flag.source.sed"
			patterns: [
				{match: "\\\\[0-9]", name: "variable.language.reference.source.sed"}
				{match: "&",         name: "variable.language.input.source.sed"}
				{include: "#escape"}
			]
		}]


	# y/ … / … /
	transliteration:
		patterns: [{
			# Absurd (yet valid) form using dash as a delimiter
			name: "meta.transliteration.source.sed"
			begin: "(y)(-)"
			end:   "(-)|$"
			beginCaptures:
				1: name: "keyword.control.command.source.sed"
				2: name: "punctuation.delimiter.transliteration.begin.source.sed"
			endCaptures:
				1: name: "punctuation.delimiter.transliteration.end.source.sed"
			patterns: [{
				# First range
				begin: "\\G"
				end:   "-|(?=$)"
				contentName: "string.quoted.double.source-characters.source.sed"
				endCaptures:
					0: name: "punctuation.delimiter.transliteration.middle.source.sed"
				patterns: [include: "#escape"]
			},{
				# Second range
				begin: "(?<=-)"
				end:   "(?=$|-)"
				contentName: "string.quoted.double.destination-characters.source.sed"
				patterns: [include: "#escape"]
			}, include: "#escape"]
		},{
			# Using a sane delimiter
			name:  "meta.transliteration.source.sed"
			begin: "y"
			end:   "$|(?<!\\G)(?=.)|(?<=^)"
			beginCaptures:
				0: name: "keyword.control.command.source.sed"
			patterns: [{
				# First range
				begin: "\\G(.)"
				end:   "-?(?=\\1|$)"
				contentName: "string.quoted.double.source-characters.source.sed"
				beginCaptures: 1: name: "punctuation.delimiter.substitution.begin.source.sed"
				endCaptures:   0: name: "string.quoted.double.source-characters.source.sed"
				patterns: [include: "#transliteration.ranges"]
			},{
				# Second range
				begin: "(.)"
				end:   "(-)?(\\1)|(?=$)"
				contentName: "string.quoted.double.replacement.source.sed"
				beginCaptures:
					1: name: "punctuation.delimiter.transliteration.middle.source.sed"
				endCaptures:
					1: name: "string.quoted.double.replacement.source.sed"
					2: name: "punctuation.delimiter.transliteration.end.source.sed"
				patterns: [include: "#transliteration.ranges"]
			}]
		}]

	"transliteration.ranges":
		patterns: [
			{match: "\\G-"}
			{match: "-", name: "keyword.operator.range.dash.source.sed"}
			{include: "#escape"}
		]


	# Modifiers for the substitute command
	flags:
		patterns: [
			# Standard flags
			{match: "g",      name: "keyword.operator.modifier.global.source.sed"}
			{match: "p",      name: "keyword.operator.modifier.print.source.sed"}
			{match: "[0-9]+", name: "keyword.operator.modifier.limit-match.source.sed"}
			
			# GNU extensions
			{match: "e",      name: "keyword.operator.modifier.exec-shell.gnu.source.sed"}
			{match: "I|i",    name: "keyword.operator.modifier.ignore-case.gnu.source.sed"}
			{match: "M|m",    name: "keyword.operator.modifier.multi-line.gnu.source.sed"}
		]
